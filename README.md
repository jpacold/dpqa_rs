# Rust DPQA compiler

This is a Rust version of a compiler for a 2D dynamically field-programmable qubit array (DPQA), described by [Tan _et al._ (2024)](https://arxiv.org/abs/2306.03487). The Python version provided by the authors can be found at [UCLA-VAST/DPQA](https://github.com/UCLA-VAST/DPQA).

## Introduction

Consider a 2D grid which can have up to two qubits at each site. Qubits that occupy the same site are close enough to execute entangling gates. Given a way to physically move qubits around the grid, we can reduce the number of SWAP gates needed to run a given set of operations. Tan _et al._ describe a system with two types of traps generated by a spatial light modulator (SLM) and an a acousto-optic deflector (AOD). Atoms in the SLM grid are stationary, while atoms in the AOD grid can be moved, with several restrictions. The most important ones are that all the atoms in a column or row of the grid must move together, and rows/columns cannot move past each other. Atoms can also be transferred between the two types of traps.

Given a sequence of two-qubit gates and a sufficiently large grid, we can use the Z3 solver to compute the necessary sequence of moves.

## Example
Suppose we have an 8-qubit circuit and want to run two-qubit gates on the following pairs:
```
(0, 2), (1, 3),
(0, 4), (1, 5),
(0, 6), (1, 7)
```
One way to do this is to keep qubits 2 through 7 fixed, while moving qubits 0 and 1. We can run the solver for this problem as follows:

```rust
use super::{DPQAResult, DPQA};
use crate::circuit::Circuit;
use crate::gates::TwoQubitGate;
use crate::gates::TwoQubitGateType::CZ;
```

```rust
// Define the sequence of gates
let mut circuit = Circuit::new();
circuit.append(TwoQubitGate::new(CZ, 0, 2));
circuit.append(TwoQubitGate::new(CZ, 1, 3));
circuit.append(TwoQubitGate::new(CZ, 0, 4));
circuit.append(TwoQubitGate::new(CZ, 1, 5));
circuit.append(TwoQubitGate::new(CZ, 0, 6));
circuit.append(TwoQubitGate::new(CZ, 1, 7));
circuit.recalculate_stages();

// Run the solver for a grid with:
//    3 rows and 2 columns of stationary qubits
//    1 row and 2 colums of mobile qubits
let dpqa = DPQA::new(3, 2, 1, 2);
let result = dpqa.solve(&circuit);
```
The result object contains a vector of `DPQAInstruction` objects that describe how to initialize and run the circuit:
```
Initialize qubit 0 at x=1, y=1 (AOD)
Initialize qubit 1 at x=0, y=1 (AOD)
Initialize qubit 2 at x=1, y=1 (SLM)
Initialize qubit 3 at x=0, y=1 (SLM)
Initialize qubit 4 at x=1, y=2 (SLM)
Initialize qubit 5 at x=0, y=2 (SLM)
Initialize qubit 6 at x=1, y=0 (SLM)
Initialize qubit 7 at x=0, y=0 (SLM)
Execute [CZ(0, 2), CZ(1, 3)]
Move qubit row [0, 1] from y=1 to y=2
Execute [CZ(0, 4), CZ(1, 5)]
Move qubit row [0, 1] from y=2 to y=0
Execute [CZ(0, 6), CZ(1, 7)]
```

## Notes
* Tan _et al._ describe two compilation strategies for this architecture: an optimal approach for small circuits, and a hybrid greedy/optimal algorithm for large circuits. So far only the optimal approach is implemented here.
* Currently the only two gates supported are CZ and CX, motivated by [Levine _et al._](https://arxiv.org/abs/1908.06101), which describes an implementation for CX and CZ compatible with the DPQA approach.
